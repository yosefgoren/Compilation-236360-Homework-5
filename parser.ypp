%{
	int yylex();
	void yyerror(const char* s);
	#include "stdio.h"
	#include "Symtab.hpp"
	#include "AuxTypes.hpp" 
	#include "hw3_output.hpp"
	#include <iostream>
	#include <algorithm>
	#include <set>
	extern int yylineno;

	//#define MYDB
	#ifdef MYDB
		#define YYERROR_VERBOSE 1
		#define YYDEBUG 1
		extern int yydebug;
#endif

	SimpleSymtab symtab;
	using namespace std;

	#define check(assertion, error) do{if(!(assertion)){error; exit(1);}}while(false);

	static int loop_depth;
	
	bool isNumeralType(ExpType type){
		return type == INT_EXP || type == BYTE_EXP;
	}
	bool canImplicitCast(ExpType source_type, ExpType dst_type){
		return (source_type == dst_type)
			|| (source_type == BYTE_EXP && dst_type == INT_EXP);
	}
	bool canExplicitCast(ExpType source_type, ExpType dst_type){
		if(source_type == dst_type)
			return true;
		return isNumeralType(source_type) && isNumeralType(dst_type);
	}

	void checkMismatch(ExpType source_type, ExpType dst_type){
		check(canImplicitCast(source_type, dst_type), output::errorMismatch(yylineno));
	}
	
	void checkBool(ExpType type) {
		checkMismatch(type, BOOL_EXP);
	}

	void checkNumeralType(ExpType type){
		check(isNumeralType(type), output::errorMismatch(yylineno));
	}

	ExpType maxNumeralType(ExpType first_operand_type, ExpType second_operand_type){
		return first_operand_type == INT_EXP ? INT_EXP : second_operand_type;
	}

	void checkFuncDec(const string& func_id, const vector<Parameter>& parameters){
		std::set<std::string> tmp_params_set;
		for(auto it = parameters.rbegin(); it != parameters.rend(); ++it){
			auto param = *it;
			//check that the new parameter identifiers don't conflict with the id of the new function:
			check(func_id != param.id, output::errorDef(param.line_of_origin, param.id));
			//check that the new parameter identifiers dont confilict with existing ones: 
			check(symtab.declarableValidId(param.id), output::errorDef(param.line_of_origin, param.id));
			//check that there are not conflitcts between the new identifiers:
			check(tmp_params_set.count(param.id) == 0, output::errorDef(param.line_of_origin, param.id));
			tmp_params_set.insert(param.id);
		}
	}

	void checkPrototypeMismatch(const string& func_id, const vector<Expression*>& reverse_exp_list_in_call){
		vector<ExpType> exp_types_required = symtab.getFunctionType(func_id).getParameterTypes();
		//TODO: add something to remember the line of each expression so we can add the correct 
		// 		line of the expression to this error (something like 'line_of_origin').
		auto required_types_it = exp_types_required.begin();
		for(auto called_exp_it = reverse_exp_list_in_call.rbegin();
				called_exp_it != reverse_exp_list_in_call.rend(); ++called_exp_it){
			
			ExpType called_type = (*called_exp_it)->type;
			if(required_types_it == exp_types_required.end() || !canImplicitCast(called_type, *required_types_it)){
				output::errorPrototypeMismatch(yylineno, func_id, ExpTypeStringVector(exp_types_required, true));
				exit(1);
			}
			++required_types_it;
		}
		if(required_types_it != exp_types_required.end()){
				output::errorPrototypeMismatch(yylineno, func_id, ExpTypeStringVector(exp_types_required, true));
				exit(1);			
		}
	}
	void checkMainMissing(){
		if (symtab.callableValidId("main")) {
			const FunctionType& func = symtab.getFunctionType("main");
			if (func.return_type != VOID_EXP || !func.getParameterTypes().empty()){
				output::errorMainMissing();
				exit(1);
			} 
		}else {
			output::errorMainMissing();
			exit(1);
		}
	}

	void checkByteTooLarge(int b) {
		if (b > 255 || b < 0) {
			output::errorByteTooLarge(yylineno, to_string(b));
			exit(1);
		}
	}
%}

%union{
	//lexer proivided fields:
	string* id;
	string* string_literal;
	int number_literal;
	
	//parser metadata fields:
	NumericExp* numeric_exp;
	Expression* expression;
	ExpType exp_type;
	vector<Expression*>* exp_list;
	vector<Parameter>* formals_list;
	Parameter* formal;
	int line_number;
	bool is_const;
	DecInfo dec_info;
};

%nonassoc INT VOID BYTE B BOOL CONST
%token TRUE FALSE
%token RETURN WHILE BREAK CONTINUE SC

%token STRING
%token COMMA
%token <id> ID
%token <number_literal> NUM

%right ASSIGN
%left OR
%left AND
%left RELOP
%left BINOP
%right NOT

%left LPAREN RPAREN LBRACE RBRACE
%right IF
%token ELSE

%type <expression> Exp NumericExp BoolExp Call
%type <exp_type> RetType Type
%type <exp_list> ExpList
%type <formals_list> Formals FormalsList
%type <line_number> LineCapture
%type <is_const> TypeAnnotation
%type <dec_info> VarDecStart
%%

Program:			Funcs
					;
OpenScope:			{symtab.pushScope();};
CloseScope:			{symtab.popScope();};
OpenLoop:			{++loop_depth;};
CloseLoop:			{--loop_depth;};
Block:				LBRACE OpenScope Statements RBRACE CloseScope;

Funcs:				FuncDecl Funcs
					|
					;
FuncDecl:			RetType ID {check(symtab.declarableValidId(*$2), output::errorDef(yylineno, *$2));}
					LPAREN Formals {	
						checkFuncDec(*$2, *$5);
						symtab.declareFunc(*$2, $1, $5);
					} RPAREN LBRACE Statements RBRACE {symtab.finishFunc();}
					;
RetType:			Type {$$ = $1;}//5
					|VOID {$$ = VOID_EXP;}//6
					;
Formals:			{$$ = new vector<Parameter>();}//7
					|FormalsList {$$ = $1;}//8 

FormalsList:		TypeAnnotation Type ID {$$ = new vector<Parameter>(); $$->push_back(Parameter(*$3, $2, yylineno, $1)); delete $3;} //9
					|TypeAnnotation Type ID LineCapture COMMA FormalsList {$$ = $6; $$->push_back(Parameter(*$3, $2, $4, $1)); delete $3;} //10
					;
LineCapture:		{$$ = yylineno;};

Statements:			Statement //12
					|Statements Statement //13
					;
Call:				ID LPAREN ExpList RPAREN {
						check(symtab.callableValidId(*$1), output::errorUndefFunc(yylineno, *$1));
						checkPrototypeMismatch(*$1, *$3);
						$$ = Expression::generateExpByType(symtab.getReturnType(*$1));
						delete $1;
					}
					|ID LPAREN RPAREN {
						check(symtab.callableValidId(*$1), output::errorUndefFunc(yylineno, *$1));
						//there are no arguments used in the call so vector is empty:
						vector<Expression*> call_arg_types = {};
						checkPrototypeMismatch(*$1, call_arg_types);
						$$ = Expression::generateExpByType(symtab.getReturnType(*$1));
						delete $1;	
					}
					;
ExpList:			Exp {$$ = new vector<Expression*>(); $$->push_back($1);}
					|Exp COMMA ExpList {$$ = $3; $$->push_back($1);}
					;
Type:				INT {$$ = INT_EXP;}
					|BYTE {$$ = BYTE_EXP;}
					|BOOL {$$ = BOOL_EXP;}
					;
TypeAnnotation:		CONST {$$ = true;}
					| {$$ = false;}
					;	
Exp:				LPAREN Exp RPAREN {$$ = $2;}
					| Call {$$ = $1;}
					| ID {
						check(symtab.rvalValidId(*$1), output::errorUndef(yylineno, *$1));
						$$ = Expression::generateExpByType(symtab.getVariableType(*$1));
						delete $1;
					}
					| STRING {$$ = new StrExp();}
					| LPAREN Type RPAREN Exp {
						check(canExplicitCast($4->type, $2), output::errorMismatch(yylineno));
						$$ = $4;
						$$->type = $2;
					}
					| NumericExp
					| BoolExp
					;

NumericExp:			Exp BINOP Exp {
						checkNumeralType($1->type);
						checkNumeralType($3->type);
						$$ = new NumericExp(maxNumeralType($1->type, $3->type));
					}
					| NUM {$$ = new NumericExp(INT_EXP);}
					| NUM B {
						$$ = new NumericExp(BYTE_EXP);
						checkByteTooLarge($1);
					}
					;

BoolExp: 			Exp AND Exp {
						checkMismatch($1->type, BOOL_EXP);
						checkMismatch($3->type, BOOL_EXP);
						$$ = new BoolExp();
					}
					| Exp OR Exp {
						checkMismatch($1->type, BOOL_EXP);
						checkMismatch($3->type, BOOL_EXP);
						$$ = new BoolExp();
					}
					| Exp RELOP Exp {
						check(isNumeralType($1->type) && isNumeralType($3->type), output::errorMismatch(yylineno));
						$$ = new BoolExp();
					}
					| NOT Exp {
						checkMismatch($2->type, BOOL_EXP);
						$$ = new BoolExp();
					}
					| TRUE {$$ = new BoolExp();}
					| FALSE {$$ = new BoolExp();}
					;

Statement:			OpenStatment
					| ClosedStatment;
					
OpenStatment:		IfStart OpenScope Statement CloseScope
					| IfStart OpenScope ClosedStatment CloseScope ELSE OpenScope OpenStatment CloseScope
					| WhileStart OpenLoop OpenScope OpenStatment CloseScope CloseLoop
					;

ClosedStatment:		SimpleStatement
					| IfStart OpenScope ClosedStatment CloseScope ELSE OpenScope ClosedStatment CloseScope
					| WhileStart OpenLoop OpenScope ClosedStatment CloseScope CloseLoop
					;
IfStart:			IF LPAREN Exp {checkBool($3->type);} RPAREN;	
WhileStart:			WHILE LPAREN Exp {checkBool($3->type);} RPAREN;

SimpleStatement:	Block
					|VarDecStart SC {
						check(!$1.is_const, output::errorConstDef(yylineno));
						symtab.declareVar(*$1.id, $1.raw_type, $1.is_const);
						delete $1.id;
					}
					|VarDecStart ASSIGN Exp SC {
						checkMismatch($3->type, $1.raw_type);
						symtab.declareVar(*$1.id, $1.raw_type, $1.is_const);
						delete $1.id;
					}
					|ID ASSIGN Exp SC {
						check(symtab.containsVar(*$1), output::errorUndef(yylineno, *$1));
						check(!symtab.isConst(*$1), output::errorConstMismatch(yylineno));
						checkMismatch($3->type, symtab.getVariableType(*$1));
						delete $1;
					}
					|Call SC
					|RETURN {checkMismatch(VOID_EXP, symtab.getCurrentlyParsedFuncType().return_type);} SC
					|RETURN Exp {
						checkMismatch($2->type, symtab.getCurrentlyParsedFuncType().return_type);
						check($2->type != VOID_EXP, output::errorMismatch(yylineno));
					} SC
					|BREAK SC {check(loop_depth!=0, output::errorUnexpectedBreak(yylineno));}
					|CONTINUE SC {check(loop_depth!=0, output::errorUnexpectedContinue(yylineno));}
					;
VarDecStart:		TypeAnnotation Type ID {
						check(symtab.declarableValidId(*$3), output::errorDef(yylineno, *$3));
						$$ = {.is_const = $1, .raw_type = $2, .id = $3};
					};

%%
void yyerror(const char* s){
	output::errorSyn(yylineno);
	exit(1);
}

void declareLibraryFuncs(){
	//FunctionType creates a shared pinter for these allocations:
	std::vector<Parameter>* print_params = new std::vector<Parameter>();
	std::vector<Parameter>* printi_params = new std::vector<Parameter>();

	//in print/i line of origin and is_const parameters are irrelevant, but have to be given some value:
	print_params->push_back(Parameter("str", STRING_EXP, 0, true));
	printi_params->push_back(Parameter("i", INT_EXP, 0, true));
	symtab.declareFunc("print", VOID_EXP, print_params);
	symtab.finishFunc(false);
	symtab.declareFunc("printi", VOID_EXP, printi_params);
	symtab.finishFunc(false);
	
}

int main(){
	#ifdef MYDB
		yydebug = 1;
	#endif
	symtab = SimpleSymtab();
	declareLibraryFuncs();
	loop_depth = 0;
	int res = yyparse();
	checkMainMissing();
	output::endScope();//this is the global scope.
	symtab.printFuncDecls();
	return res;
}